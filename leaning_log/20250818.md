# 예외(Exception)
## 예외(Exception)란?
- 개발자가 예측할 수 있고 ,그에 대한 대비를 할 수 있는 것들을 예외라고 한다.

### 오류(Error)란?
- 개발자가 예측할 수 있지만 해결할 수 없거나 / 예측 불가능한 것을 오류라고 정의하는 편이다.

## 고전적 형태의 예외처리 방식
- if문을 사용하여 예외를 처리했다.
```java
public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();
    if (b == 0) {
        System.out.println("나눌 수 없습니다.");
    } else {
        System.out.println("결과값은 : " + (a / b));
    }
}
```

## 현재 사용중인 예외처리 방식
- try / catch / finally 의 형태의 예외처리를 사용한다.
```java
public static void main(String[] args) {
    int a = 10;
    int b = 0;
    try {
        // try문 내부 실행중 에러가 발생할 시 catch문으로 이동하게 된다.
        int result = a / b;             //에러발생
        System.out.println(result);
    } catch (ArithmeticException e) {
        // 에러가 발생하면 예외처리로 지정한 catch부분으로 넘어가서 프로그램을 실행한다.
        System.out.println("0으로 나눌 수 없습니다. : " + e.getMessage());  
    } finally {
        // 이후 최종적으로 finally문을 마지막으로 실행을 한다.
        System.out.println("프로그램 정상 종료");
    }
}
```
- catch문을 복수로 사용도 가능하다.
```java
public static void main(String[] args) {
    // 배열 인덱스 예외 -> 복수 catch문 사용
    int[] numbers = {1, 2, 3};
    try {
        System.out.println(numbers[5]);
    }catch (ArrayIndexOutOfBoundsException e){
        System.out.println(e.getMessage());
    }catch (Exception e){                       // 예외 중에 가장 상위 예외 클래스에 해당함.
        throw new RuntimeException(e);
    }finally {
        System.out.println("프로그램 정상종료");
    }
}
```
### 예외처리를 하는 이유?
- 코드적으로 프로그램을 정상 종료 하기 위해서이다.

### 사용에 대해
- 다수의 예외의 경우에는 이미 개발자들이 정의를 해 놓았다. 예를 들어 List를 하나 정의 했고, 거기에 element들을 집어넣었다고 가정하면 그 경우 List의 element들을 추출하게 되는데 이때 Size()메서드를 사용하지 않고 하드코딩하여 사이즈를 벗어나게 되어 예외가 발생하게 된다.




# 람다식(Lambda Expression)
- Java 8에서 도입된 함수형 프로그래밍을 지원하기 위한 조건식

형식 :

```java
// (매개변수) -> { 실행문 }
public static void main(String[] args) {
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            System.out.println("Hello, Java");
        }
    }
    runnable.run();     // Hello, Java가 출력
}
```
Interface인 Runnable을 활용하여 임시적으로 run() 추상 메서드를 재정의하여 원하는 출력 결과를 도출하는 형태이다.
하지만 길이가 길다.

```java
public static void main(String[] args) {
    Runnable lambdarunnable = () -> System.out.println("Hello, Java");

    lambdarunnable.run();
}
```
이상이 위 코드가 람다식을 사용한 코드이다.


## 등장 배경
- 람다식이 나오기 전에는 Java에서 함수형 프로그래밍을 하기 위해 익명 클래스를 주로 사용 하였다.
- 하지만 아상의 방식은 예시에서 볼 수 있듯 코드가 길어지고, 불필요한 반복이 많아 가독성이 떨어졌다.

```java
import java.util.Comparator;

public static void main(String[] args) {
    Comparator<Integer> comparator = new Comparator<Integer>() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return o1.compareTo(o2);
        }
    } // Comparator 인터페이스의 객체를 이용한 작성방법
    
    Comparator<Integer> lambdaComparator = (o1, o2) -> o1.compareTo(o2);
}
```

## 람다식 장점
1. 코드 간결화 - 불필요한 코드 제거로(Integer 반복이 없죠), 가독셩 향상
2. 표현력 향상 - 익명 클래스를 짧은 표현으로 대체
3. 지연 연산 - Stream API와 함께 사용 시 지연 연산을 통해 성능 최적화

## 람다식 단점
1. 디버깅 어려움 - 람다식 내부에서 발생하는 오류의 디버깅이 어렵다.
2. 재사용성 낮음 - 익명 클래스에 '비해' 재사용이 어렵다.
3. 복작한 로직 표현에 부적합 - 단순 로직의 경우 람다식 사용, 아닌경우는 익명 클래스 사용

## 람다식 문법
람다식 구조는 크게 3 가지로 나뉜다.
1. 매개변수 목록
2. 화살표 (->) : 그래서 Js에서는 arrow expression 이라고 하낟.
3. 구현부/ 실행문(IntelliJ에서는 메서드 본문)

```java
public static void main(String[] args) {
    // 1. 매개변수와 실행문이 하나일 때(중괄호 생략 가능)
    (int x, int y) -> x + y;
    
    // 2. 매개변수가 하나일 때(소괄호 생략 가능)
    str -> System.out.println(str);

    // 3. 실행뭉이 여러줄 일 때(중괄호 필수)
    (x, y) -> {
        int sum = x + y;
        return sum;
    }
}
```
## 함수형 인터페이스 (Functional Interface)
- 람다식은 단일 메서드만 가지는 인터페이스 (이를 함수형 인터페이스라고 한다.)를 구현하는 형태로 사용된다. `@FunctionalInterface` 애너테이션을 사용하면 컴파일 시에 단일 메서드인지 체크한다.
- 그래서 '사용자 정의 함수형 인터페이스'를 작성할 때 클래스 레벨에 `@FunctionalInterface`를 명시해 준다.

인터페이스에 있는 메서드는 전부 _추상 메서드_이다.

하지만 여러 유형의 메서들 하나의 객체에 강제 구현하게 될 경우 특정 유형만 필요한데 나머지도 정의해야한다는 문제가 발생하기 때문에 하나의 인터페이스/추상메서드만 존재하게 되었다.

```java
@FunctionalInterface
interface MyFunction{
    void start();
}

public static void main(String[] args) {
    MyFuction myFucntion = () -> System.out.println("정의한 함수를 실행합니다.");
    // 매개변수가 아예없는 경우는 ()로 표시
    
    myFucntion.start();
}
```
## Java에서 제공하는 주요 '함수형 인터페이스'
1. Runnable - void run();
2. Supplier - T get();    -return 존재
3. Consumer - void accept(T,t)
4. Function<T, R> - R apply(T, t);    -return 존재
5. Predicate - boolean test(T, t);    - return 타입이 boolean고정

### 함수령 인터페이스 별 상세
1. Runnable
   - 매개변수도 없고, 반환값도 없는 단순 실행 메서드
   - 사용처 : 스레드 실행 시, 비동기 작업 실행시
2. Supplier
   - 매개변수 없이 값을 반화하는 인터페이스, 단순히 값을 '공급'하는 역할
   - 사용처 : 객체생성, 지연로딩
3. Consumer
   - 값을 매개변수로 받아서 사용하고, 아무 것도 반환하지 않는 인터페이스, 데이터를 '소비'하는 역할
   - 사용처 : 데이터 처리, 로깅, 이벤트 핸들러
4. Function<T, R>
   - '하나의 매개변수'를 받아서, 연산을 수행한 후 결과를 리턴함.
   - 사용처 : 
5. Predicate
   - '하나의 매개변수'를 받아서 특정 조건을 검사한 뒤 true/false 반환
   - 사용처 : 필터링, 조건검사, 유효성 검사
   - 특히 Predicate의 경우 결과 반환값으로 조건문을 돌릴 때 많이 사용한다.
6. 함수형 인터페이스 조합
   - Java 8에서는 함수형 인터페이스 끼리의 조합이 가능하다.

```java
import java.util.function.Predicate;

public static void main(String[] args) {
    // 메서드1
    Predicate<String> startsWithA = str -> str.startsWith("A");
    // 메서드2
    Predicate<String> endsWithX = str -> str.endsWith("X");
    
    // and() 로 두 조건 결합
    Predicate<String> startsWithAAndwithX = startsWithA.and(endsWithX);

    System.out.println(startsWithAAndwithX.test("Alex"));
}
```
# 시험 관련 안내
09 : 00 안내 시작 -> 09:10 ~ 17:50
객체지향 프로그래밍 언어
1. 프로그래밍 언어 활용
2. 프로그램밍 언어 응용

## 프로그래밍 언어 활용
20문제 서답형

.md 파일 상에서 명시적으로 정리되지 않은 부분이 있다.
구글 검색 가능
Github, 자체정리 코드, 노트 확인 가능

- 특정 문제가 md 파일에 없다는 것을 확신한다면 구글에서 검색해서 알아봐야 한다.

특정 메서드 이름을 적으시오
특정 자료형을 적으시오
키워드를 적으시오...등

예비 선발 문제에서도 한 문제
예외에서 한 문제

## 프로그래밍 언어 응용 
JSON        - 20
Singleton   - 20
Builder     - 30
Collection  - 30

저장만 누르면 안되고 제출까지 해야한다.
허나, 제출 시 수정이 안됨
60점 미만은 재시험 대상자
1과목 / 2과목 -> 독립시행 한 과목만 60점 미만이면 미만인 과목만 재시험


