# Getter/Setter

## Getter/Setter의 등장 배경

1. 등장 배경

- 클래스를 작성할 때 여러 정보를 필드로 선언한다.

```java
public class Person {
    Stirng name;
    int age
}

public class PersonMain {
    public static void main(String[] args) {
        Person person = new Person();
        person.name = "김일";
        person.age = -10;

        System.out.println(person.name); // 결과값 : 김일
        System.out.println(person.age); // 결과값 : -10
    }
}
```

이상의 코드를 확인 했을 때, 나이에 정상적이지 않은 값이 대입되어 있습니다. 이처럼 외부에서
직접 속성값을 대입하게 될 때, 이상한 값이 들어가더라도 통제할 수 있는 방법이 없다는 문제가 있다.

-> 이상을 해결하기 위한 방법이 getter/setter의 개념이다.

## Getter/Setter 란?

### Setter

- 데이터를 '설정'하는 역할의 'method' 클래스 외부에서 플드를 직업 수정하지 못하도록 막고
  특정 메서드를 경유하여 값을 전달 받아 '초기화 및 수정'을 하도록 함.

### Getter

- 데이터를 '조회'하는 역할의 'method' 클래스 위부에서 필드를 직접 읽지 못하도록 막고
  직접 접근하지 못하게 함으로써 데이터를 보호할 수 있음.

### 장점

1. 데이터의 보호
    - 변수가 private 접근 제어자를 사용하여 외부에서 직접 접근하지 못하게 함으로써
      데이터를 보호 할 수 있음
2. 데이터의 유효성 검증
    - Setter 메서드에서 입력된 ㄷ데이터가 적합한지 확인하고, 잘못된 값을 거절할 수 있음
3. 캡슐화(Encapsulation)
    - 데이터를 숨기고 필요한 경우에만 제한저긍로 접근할 수 있도록 하여 클래스 내부 구현을 외부로
      노출하지 않음
4. 유연성 증가
    - 나중에 요구사항이 바뀌어 데이터를 설정하거나 조회하는 방법이 변경되더라도
      클래스 내부의 메서드만 수정하면 되므로 유지보수가 간단.

## Getter/Setter 구조

```
접근지정자 void set속성명(변수자료형 변수명) {
    this.set속성명 = 변수명;
}

접근지정자 get속성변수자료형 get속성명() {
        return 속성명;
    }
```

## Setter를 이용한 유효성 검증 예시

```java
public class Person {
    private int age;

    public void setAge(int age) {
        if (age < 0 || age > 200) {
            System.out.println("불가능한 나이입니다.");
            return;
        }
        System.out.println("변경 전 나이 : " + age);
        this.age = age;
        System.out.println("변경 후 나이 : " + age);
    }
}
```

# 접근지정자 (AccessModifier)

## 정의

- 클래스, 필드, 변수, 메서드의 접근 범위를 제어하는 키워드
- 사용 이유
    - 정보 은닉(캡슐화: Encapsulation)을 실현하고, 코드의 보안성과 유지 보수성을 위해

## 접근 지정자의 종류

1. public - 모든 클래스에서 접근 가능
   - Setter/ Getter를 생성하게 되면 public 인것을 확인 가능한데 이것이 애초에 다른 클래스에서
     사용 할라고 만든 것 이기 때문에 기본적으로 public으로 생성된다
   - 완전히 공개된 상태이다.
   - 누구나 사용이 가능하다
   - 보통 라이브러리나 API의 공개된 기능에 사용된다.
    ```java
    public class Car{
        public String model = "셀토스";
        
        public void drive(){
            System.out.println("자동차를 운전합니다.");
        }
    }
    ```
    - 이상의 코드는 다른 어떤 클래스를 생성하더라도 경로만 정확하다면 객체를 생성할 수 있고(class가 public이라서),
    car1이라는 객체를 생성 후 car1.model로 필드에 변수에도 접근이 가능하며 car1.drive()로 메서드를 호출해도 문제없이 호출 될 것이다.

2. protected - 같은 패키지 내의 클래스 및 이 클래스를 상속받은 자식 클래스에서 접근 가능
   - 기본적으로는 default와 같지만 자식클래스에서 상속 받아서 사용 가능하다.
    ```java
    package vehicle;
    public class Car{
        protected String brand = "기아";
    }
    
    //============ 같은 패키지 다른 클래스
    package vehicle;
    
    import vehicle.Car
    
    public class MyCar extends Car{
        public void showBrand(){
            System.out.println(brand);
        }
    }
    ```
    - 상속을 하면 사용이 가능해 진다.


3. default - 접근 지정자를 명시하지 않으면 defalut로 간주되며, 같은 패키지 내의 클래스에서 접근 가능
   - 같은 패키지 안에서는 접근 가능, 다른 패키지에서는 불가능
    ```java
    class Car{
        String color = "red";
    }
    ```
    - 위 코드의 경우, class  레벨도 default / 필드 레벨도 default라고 볼 수 있다. 같은 패키지 내부에서는 호출도 객체생성도 가능하지만 패키지 외부로 나가게 되는 경우 호출도 불가능해진다.    

4. private - 같은 클래스 내에서만 접근 가능
   - 가장 제한적인 접근 지정자이다.
   - 클래스 외부로부터 접근이 불가능하다.
   - 웬만한 클래스에서는 데이터 보호 목적으로 필드를 설정할 때 private를 이용한다.
   - 강제로 특정한 필드에 접속 하지 못하게 하여 변수이름의 사용을 다양하게 할 수 있다.
   - Getter를 사용할 경우 테이터의 가공도 가능해 진다.
    ```java
    public class Car {
        private String engine = "V6";
        
        public void showEngine(){
            System.out.println("엔진정보:" + engine);
        }
    }
    
    public class CarMain{
        public static void main(String[] args) {
            Car car1 = new Car();
            System.out.println(car1.engine); // 컴파일 오류: 필드 자체는 private이기 때문에 호출 불가능하다.
            car1.showEngine();
            // method는 public이며 method 내부에 engine 변수를 사용하여 클래스 내부에서 사용하기 때문에 호춣이 가능하다.
            
        }
    }
    
    ```
   - Car를 기준으로 필드는 private, 일부 정보를 공개하게 되는 메서드는 public이기 때문에 객체 생성 후 필드 변수를 호출해 보지만 같은 클래스 내부에서 호출되는게 아니라 컴파일 에러가 발생하며 메서드 같은 경우 public이라 호출이 가능하다.


## 실무적 관점 접근지정자 선택
1. 필드는 원칙적으로 private
2. 메서드는 외부 공개 필요 시 public
3. 상속 대상 메서드는 protected
4. 패키지 내부에서만 쓰이는 도우미 클래스 default

### 항상 그런 것은 아니지만 염두 하면 좋은 부분
1. 필드는 웨만하면 private로 지정하고, 접근은 게터/세터를 통해하자
2. 인터페이스나 라이브러리는 public을 최소화 할 것, 이미 공개된 API는 되돌리기 어려움
   - 다른 회사가 내가 만든 class를 쓰고 있는데 멀정하게 public으로 되어있던게 default로 바뀌게 되면
   그 회사는 더이상 제가 만든 class를 사용하지 못하게 될꺼고 기존 로직을 변경하여야 한다.









