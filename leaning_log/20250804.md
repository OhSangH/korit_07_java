# Getter/Setter

## Getter/Setter의 등장 배경

1. 등장 배경

- 클래스를 작성할 때 여러 정보를 필드로 선언한다.

```java
public class Person {
    Stirng name;
    int age
}

public class PersonMain {
    public static void main(String[] args) {
        Person person = new Person();
        person.name = "김일";
        person.age = -10;

        System.out.println(person.name); // 결과값 : 김일
        System.out.println(person.age); // 결과값 : -10
    }
}
```

이상의 코드를 확인 했을 때, 나이에 정상적이지 않은 값이 대입되어 있습니다. 이처럼 외부에서
직접 속성값을 대입하게 될 때, 이상한 값이 들어가더라도 통제할 수 있는 방법이 없다는 문제가 있다.

-> 이상을 해결하기 위한 방법이 getter/setter의 개념이다.

## Getter/Setter 란?

### Setter

- 데이터를 '설정'하는 역할의 'method' 클래스 외부에서 플드를 직업 수정하지 못하도록 막고
  특정 메서드를 경유하여 값을 전달 받아 '초기화 및 수정'을 하도록 함.

### Getter

- 데이터를 '조회'하는 역할의 'method' 클래스 위부에서 필드를 직접 읽지 못하도록 막고
  직접 접근하지 못하게 함으로써 데이터를 보호할 수 있음.

### 장점

1. 데이터의 보호
    - 변수가 private 접근 제어자를 사용하여 외부에서 직접 접근하지 못하게 함으로써
      데이터를 보호 할 수 있음
2. 데이터의 유효성 검증
    - Setter 메서드에서 입력된 ㄷ데이터가 적합한지 확인하고, 잘못된 값을 거절할 수 있음
3. 캡슐화(Encapsulation)
    - 데이터를 숨기고 필요한 경우에만 제한저긍로 접근할 수 있도록 하여 클래스 내부 구현을 외부로
      노출하지 않음
4. 유연성 증가
    - 나중에 요구사항이 바뀌어 데이터를 설정하거나 조회하는 방법이 변경되더라도
      클래스 내부의 메서드만 수정하면 되므로 유지보수가 간단.

## Getter/Setter 구조

```
접근지정자 void set속성명(변수자료형 변수명) {
    this.set속성명 = 변수명;
}

접근지정자 get속성변수자료형 get속성명() {
        return 속성명;
    }
```

## Setter를 이용한 유효성 검증 예시

```java
public class Person {
    private int age;

    public void setAge(int age) {
        if (age < 0 || age > 200) {
            System.out.println("불가능한 나이입니다.");
            return;
        }
        System.out.println("변경 전 나이 : " + age);
        this.age = age;
        System.out.println("변경 후 나이 : " + age);
    }
}
```

# 접근지정자 (AccessModifier)

## 정의

- 클래스, 필드, 변수, 메서드의 접근 범위를 제어하는 키워드
- 사용 이유
    - 정보 은닉(캡슐화: Encapsulation)을 실현하고, 코드의 보안성과 유지 보수성을 위해

## 접근 지정자의 종류

1. public - 모든 클래스에서 접근 가능
   - Setter/ Getter를 생성하게 되면 public 인것을 확인 가능한데 이것이 애초에 다른 클래스에서
     사용 할라고 만든 것 이기 때문에 기본적으로 public으로 생성된다

2. protected - 같은 패키지 내의 클래스 및 이 클래스를 상속받은 자식 클래스에서 접근 가능
 
3. default - 접근 지정자를 명시하지 않으면 defalut로 간주되며, 같은 패키지 내의 클래스에서 접근 가능

4. private - 같은 클래스 내에서만 접근 가능
   - 그래서 같은 
   - 강제로 특정한 필드에 접속 하지 못하게 하여 변수이름의 사용을 다양하게 할 수 있다.
   - Getter를 사용할 경우 테이터의 가공도 가능해 진다.


