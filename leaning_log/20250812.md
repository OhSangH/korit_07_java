# Static

## 정의

- 클래스 수준에서 변수를 정의하거나 메서드를 선언할 때 사용
- static으로 선언된 변수나 메서드는 클래스의 '인스턴스에 속하지 않는다.' (해당 클래스의 인스턴스가 전부 동일 한 값으로 공유 함을 의미)
- 클래스 자체에 속하게 된다.
- 이는 인스턴스를 생성하지 않고도 접근이 가능하다는 점에서 일반적인 필드, 메서드와 구분된다.

## 특징

1. 공유 : 모든 인스턴스가 동일한 static 변수에 접근합니다. 따라서 데이터를 공유하거나 상태를 저장할 때 유용

2. 클래스 수준의 변수 및 메서드 : static 변수와 메서드는 클래스 로드 시 메모리에 할당 (객체가 생성될 때가 아니라)
    ```java
    @AllArgsConstuctor
    public class KoreaItStudent07 extends KoreaItStudent{
        //클래스 변수 선언
        private static String introduction = "코리아 아이티 국비 과정 7월";
        // 필드 정의  
        private String name;
        private int age;
        private String address;
    }
    
    public class Main{
        public static void main(String[] args) {
            KoreaItStudent07 student07 = new KoreaItStudent07("김일", 20, "부산광역시" );
        }
    }
    ``` 
   위 코드가 클래스의 인스턴트들은 전부다 private static String의 '정적 변수'를 가지게 된다. 즉, 어느 클래스의 인스턴스이지만 확인하더라도 무슨 변수인지 확인할 수 있습니다.

3. 인스턴스가 필요 없음 : 객체를 생성하지 않고도 클래스명.필드 / 클래스명.메서드() 형태로 직접 접근이 가능하다.(필드는 private가 아니어야만 한다.)

4. 메모리 효율성 : static 변수는 프로그램이 종료될 때까지 단 한 번만 메모리에 할당된다.

# Singleton Pattern (싱글톤 패턴)

## 정의

소프트웨어 `디자인 패턴` 중 하나로, 어떤 클래스가 '하나의 인스턴스만 갖도록 보장하고', 그 인스턴스에 접근할 수있는 '전역적인 접근법'을 제공하는 패턴. 예를 들어, 데이터베이스 연결과 같은 리소스는 프로그램
전체에서 하나의 인스턴스만 사용해야 할 때가 많기 때문에 싱글톤 패턴을 사용한다.

## 특징

1. 하나의 이스턴스만 존재 : 하나의 인스턴스만 생성되고, 이 인스턴스는 프로그램이 싱행되는 동안 유지
2. 전역 접근법 : 싱글톤 인스턴스는 정적 메서드를 통하여 어디서든 접근 가능 -> 객체명.메서드() X / 클래스명.메서드()
3. 인서튼서의 생명주기 관리 : 클래스 자체가 인스턴스 생성을 관리하므로, 다른 객체들이 인스턴스를 생성하거나 폐기 할 수 없다.

## 장점

1. 메모리 절약 : 불필요한 인스턴스 생성을 방지하여 메모리 절약 가능 (static 변수 / 메서드의 장점과 같다.)
2. 글로벌(전역적) 접근 : 전역적 접근이 가은하여 메모리 관리가 용의 -> 다만 잦은 접근 자체는 단점
3. 일관성 유지 : 애플리케이션 전바에서 하나의 인스턴스만 사용하기 때문에 상태 일관성 유지

## 단점

1. 테스트 어려움 : 싱글톤 패턴은 전역적으로 사용되므로 단위 테스트가 어려울 수 있다.
2. 의존성 숨김 : 싱글톤을 남용하면 클래스 간의 의존성을 추적하기 어려울 수 있다.


# 빌더 패턴 (Builder Pattern)
기존의 생성자를 작성하는 방식
```java
@AllArgsConstructor 
public class Student{
    private int code;
    private String name;
    private String gender;
    private String school;
    private int semester;
    private String[] subjects;
    private int[] scores;
}

public class StudentMain{
    public static void main(String[] args) {
        Student student1 = new Student(field가 전부 들어가야함 심지어 순서대로);
                
        
    }
}
```
위 코드와 같이 기존처럼 작성하게 되면 생성자를 통해 객체를 생성하게 되는경우 다수의 매변수를 필요하게 되고 거기에 매게변수의 순서에 맞게 기입을 해야한다.
이렇게 작성을 하게 되면 상당히 코드 작성이 어렵고 가독성도 불편해 지게 된다. 이를 해결하기 위해 만들어 진것이 빌더 패턴이다.
## 빌더패턴이 생기게 된 원인
1. 복잡한 생성자 문제
   - 객체의 필드가 많아 질 수록 생성자 파라미터 수도 늘어난다.
     - 위 예시에서 모든 매개변수생성자를 정으 ㅣ했지만 종류별로 써야한다
     - 롬복을 도입했다고 하더라도 필수적인것은 final이나 @nonNull을 추가로 지정해 줘야하며
2. 생성자 오버로딩 문제
   - 생성자에 필요한 조합이 다를 경우 수 많은 생성자드을 일일이 정의 해야 합니다.
   - 유지 보수에 악영향/ 필드 하나 추가하면 생성자를 다 뜯어 고쳐야함.
     -  RemoteController 작성할 때, VolumeDownButton을 추가하니까 main단계에 있는 생성자에 필드 추가해 줘야하고, 생성자 지웠다가 alt + ins 해서 다시 만들어주고 하는 귀찮은 과정들이 있었다.
3. 가독성과 유지보수 문제
   - 코드를 작성하고 읽는 입장에서는 객체를 생성할 때 어떤 값이 어떤 필드에 해당하는지 명확하지 않아서 실수를 유발할 수 있다.
    ```java
    public static void main(String[] args){
      Student student1 = new Student("김일", "김이");
      //라고 했을 때 김일 초등학교의 김이 학생인지 김일 학생이 김이 초등학교인지 알게 뭐냐는 문제가 있습니다.
    }
    ``` 
   
## 정의
객체의 생성 과정에서 '복잡한 생성자'를 대신하여 객체를 '단계적으로' 생성할 수 딨도록 도와주는 디자인 패턴 중 생성 관련 파트. Gof(Gang of Four) 디자인 패턴중 하나로 객체 생성 시 가독성과 유연성을 제공하는 것이 목표.
    - 여기서 유연성의 의미는 필드를 순서대로 채워넣지 않고 순서를 바꾸더라도 제대로 알아서 필드에 들어간다는 것을 의미한다.
```java
public class Student {
    private String name;
    private String schoool;

    public Student(String name, String schoool) {
        this.name;
        this.schoool;
    }

    public Student(String schoool, String name) {
        this.schoool;
        this.name
    }
}
```

## 특징
1. 객체를 생성하는 여러개의 필드를 '명시적'으로 관리할 수 있다.
2. 불필요한 생성자 오버로딩 (위의 예시)을 줄여 가독성을 높인다.
3. 체이닝 메서드를 사용하여 객체를 직관적으로 생성
